"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Kenneth Herrera. All rights reserved.
 *  Licensed under the MIT License. See LICENSE in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Types = exports.TypeParse = void 0;
const Utils_1 = require("./Utils");
class TypeParse {
    constructor(parseConfig) {
        this.config = parseConfig;
    }
    _parse(input, config, relativePath) {
        switch (config.as) {
            case "object":
                return this.parseObject(input, config, relativePath);
            case "array":
                return this.parseArray(input, config, relativePath);
            case "string":
                return this.parseString(input, config, relativePath);
            case "number":
                return this.parseNumber(input, config, relativePath);
            case "boolean":
                return this.parseBoolean(input, config, relativePath);
            case "union":
                return this.parseUnion(input, config, relativePath);
            default:
                return this.parseAny(input, config, relativePath);
        }
    }
    parse(input) {
        return this._parse(input, this.config);
    }
    parseString(input, config, relativePath) {
        if (config.from)
            input = (0, Utils_1.get)(input, config.from);
        else
            input = (0, Utils_1.get)(input, relativePath);
        if (typeof input === "string")
            return input;
        if (typeof input === "number" || typeof input === "boolean")
            return `${input}`;
        if (config.defaultValue !== undefined) {
            return config.defaultValue;
        }
        else if (config.isOptional) {
            return undefined;
        }
        else {
            throw Error("Cannot parse string");
        }
    }
    parseNumber(input, config, relativePath) {
        if (config.from)
            input = (0, Utils_1.get)(input, config.from);
        else
            input = (0, Utils_1.get)(input, relativePath);
        if (typeof input === "number")
            return input;
        if (typeof input === "string") {
            const result = Number.parseFloat(input);
            if (!isNaN(result)) {
                return result;
            }
        }
        if (config.defaultValue !== undefined) {
            return config.defaultValue;
        }
        else if (config.isOptional) {
            return undefined;
        }
        else {
            throw Error("Cannot parse number");
        }
    }
    parseBoolean(input, config, relativePath) {
        if (config.from)
            input = (0, Utils_1.get)(input, config.from);
        else
            input = (0, Utils_1.get)(input, relativePath);
        if (typeof input === "boolean")
            return input;
        if (!config.strict && typeof input !== "undefined")
            return !!input;
        if (config.defaultValue !== undefined) {
            return config.defaultValue;
        }
        else if (config.isOptional) {
            return undefined;
        }
        else {
            throw Error("Cannot parse boolean");
        }
    }
    parseAny(input, config, relativePath) {
        if (typeof input !== "object")
            return input;
        if (config.from)
            input = (0, Utils_1.get)(input, config.from);
        else
            input = (0, Utils_1.get)(input, relativePath);
        return input;
    }
    parseArray(input, config, relativePath) {
        if (config.from)
            input = (0, Utils_1.get)(input, config.from);
        else
            input = (0, Utils_1.get)(input, relativePath);
        if (!Array.isArray(input)) {
            if (config.isOptional)
                return undefined;
            throw Error("Is not array");
        }
        const results = [];
        input.forEach((element) => {
            const parsed = this._parse(element, config.type);
            if (parsed !== undefined)
                results.push(parsed);
        });
        return results;
    }
    parseObject(input, config, relativePath) {
        if (typeof input !== "object") {
            if (config.isOptional)
                return undefined;
            throw Error("Is not object");
        }
        const result = {};
        try {
            Object.entries(config.properties).forEach(([key, value]) => {
                result[key] = this._parse(input, value, relativePath ? `${relativePath}.${key}` : key);
            });
        }
        catch (error) {
            if (config.isOptional)
                return undefined;
            throw error;
        }
        return result;
    }
    parseUnion(input, config, relativePath) {
        for (const value of config.types) {
            try {
                return this._parse(input, value, relativePath);
            }
            catch (_a) {
                continue;
            }
        }
        if (config.isOptional) {
            return undefined;
        }
        else {
            throw new Error("Cannot parse to match any type of union");
        }
    }
}
exports.TypeParse = TypeParse;
const optional = (option) => {
    return Object.assign(Object.assign({}, option), { isOptional: true, optional: undefined });
};
exports.Types = {
    String: (from, config) => {
        return {
            $static: undefined,
            as: "string",
            defaultValue: config === null || config === void 0 ? void 0 : config.defaultValue,
            isOptional: false,
            optional: function () {
                return optional(this);
            },
            from,
        };
    },
    Number: (from, config) => {
        return {
            $static: undefined,
            as: "number",
            defaultValue: config === null || config === void 0 ? void 0 : config.defaultValue,
            isOptional: false,
            optional: function () {
                return optional(this);
            },
            from,
        };
    },
    Boolean: (from, config) => {
        return {
            $static: undefined,
            as: "boolean",
            defaultValue: config === null || config === void 0 ? void 0 : config.defaultValue,
            strict: (config === null || config === void 0 ? void 0 : config.strict) !== undefined ? config.strict : true,
            isOptional: false,
            optional: function () {
                return optional(this);
            },
            from,
        };
    },
    Any: (from, config) => {
        return {
            $static: undefined,
            as: "any",
            defaultValue: config === null || config === void 0 ? void 0 : config.defaultValue,
            isOptional: false,
            optional: function () {
                return optional(this);
            },
            from,
        };
    },
    Array: (type, from) => {
        return {
            $static: undefined,
            as: "array",
            isOptional: false,
            optional: function () {
                return optional(this);
            },
            from,
            type,
        };
    },
    Object: (properties) => {
        return {
            $static: undefined,
            as: "object",
            isOptional: false,
            optional: function () {
                return optional(this);
            },
            properties,
        };
    },
    Union: (types) => {
        return {
            $static: undefined,
            as: "union",
            isOptional: false,
            optional: function () {
                return optional(this);
            },
            types,
        };
    },
};
